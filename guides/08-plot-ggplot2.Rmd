---
title: Creating Publication-Quality Graphics with ggplot2
teaching: 60
exercises: 20
source: Rmd
---

::::::::::::::::::::::::::::::::::::::: objectives

- To be able to use ggplot2 to generate publication-quality graphics.
- To apply geometry, aesthetic, and statistics layers to a ggplot plot.
- To manipulate the aesthetics of a plot using different colors, shapes, and lines.
- To improve data visualization through transforming scales and paneling by group.
- To save a plot created with ggplot to disk.

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::: questions

- How can I create publication-quality graphics in R?

::::::::::::::::::::::::::::::::::::::::::::::::::

This code is cribbed from our earlier discussion about dplyr / data munging (13-dplyr.pdf).

```{r, include=FALSE}
library(dplyr)
library(readr)
eiad <- read_csv("https://github.com/davemcg/2024_04_20_NEI_Vision_Course/raw/main/guides/data/eyeIntegration23_meta_2023_09_01.built.csv.gz")
eiad_expression <- read_csv('https://github.com/davemcg/2024_04_20_NEI_Vision_Course/raw/main/guides/data/eiad_gene_expression.csv.gz')

eiad_meta_exp <- eiad %>% 
  select(-run_accession, -sample_title, -gtex_sra_run_accession) %>% 
  unique() %>% 
  left_join(eiad_expression, by = c('sample_accession' = 'name')) 

```

Plotting our data is one of the best ways to
quickly explore it and the various relationships
between variables.

There are three main plotting systems in R,
the [base plotting system][base], the [lattice]
package, and the [ggplot2] package.

Today we'll be learning about the ggplot2 package, because
it is the most effective for creating publication-quality
graphics.

ggplot2 is built on the grammar of graphics, the idea that any plot can be
built from the same set of components: a **data set**,
**mapping aesthetics**, and graphical **layers**:

- **Data sets** are the data that you, the user, provide.

- **Mapping aesthetics** are what connect the data to the graphics.
They tell ggplot2 how to use your data to affect how the graph looks,
such as changing what is plotted on the X or Y axis, or the size or
color of different data points.

- **Layers** are the actual graphical output from ggplot2. Layers
determine what kinds of plot are shown (scatterplot, histogram, etc.),
the coordinate system used (rectangular, polar, others), and other
important aspects of the plot. The idea of layers of graphics may
be familiar to you if you have used image editing programs
like Photoshop, Illustrator, or Inkscape.

Let's start off building an example using the gapminder data from earlier.
The most basic function is `ggplot`, which lets R know that we're
creating a new plot. Any of the arguments we give the `ggplot`
function are the *global* options for the plot: they apply to all
layers on the plot.

```{r blank-ggplot, message=FALSE, fig.alt="Blank plot, before adding any mapping aesthetics to ggplot()."}
library("ggplot2")
ggplot(data = eiad_meta_exp)
```

Here we called `ggplot` and told it what data we want to show on
our figure. This is not enough information for `ggplot` to actually
draw anything. It only creates a blank slate for other elements
to be added to.

Now we're going to add in the **mapping aesthetics** using the
`aes` function. `aes` tells `ggplot` how variables in the **data**
map to *aesthetic* properties of the figure, such as which columns
of the data should be used for the **x** and **y** locations.

```{r ggplot-with-aes, message=FALSE, fig.alt="Plotting area with axes for a scatter plot of life expectancy vs GDP, with no data points visible."}
ggplot(data = eiad_meta_exp, mapping = aes(x = Tissue, y = `KERA (ENSG00000139330)`))
```

Here we told `ggplot` we want to plot the "Tissue" column of the
eiad_meta_exp data frame on the x-axis, and the "KERA (ENSG00000139330)" column on the
y-axis. Notice that we didn't need to explicitly pass `aes` these
columns (e.g. `x = eiad_meta_exp[, "KERA (ENSG00000139330)"]`), this is because
`ggplot` is smart enough to know to look in the **data** for that column!

The final part of making our plot is to tell `ggplot` how we want to
visually represent the data. We do this by adding a new **layer**
to the plot using one of the **geom** functions.

```{r kera by tissue, message=FALSE, fig.alt="Scatter plot of life expectancy vs GDP per capita, now showing the data points."}
ggplot(data = eiad_meta_exp, mapping = aes(x = Tissue, y = `KERA (ENSG00000139330)`)) + geom_point()
```

Here we used `geom_point`, which tells `ggplot` we want to visually
represent the relationship between **x** and **y** as a scatterplot of points.

:::::::::::::::::::::::::::::::::::::::  challenge

## Challenge 1

Modify the example so that the figure shows how Rho expression changes within sub_tissues of only eye tissues

```{r, eval=FALSE}
ggplot(data = eiad_meta_exp, mapping = aes(x = Tissue, y = `KERA (ENSG00000139330)`)) + geom_point()
```

Hint: You can pipe data into ggplot like so:
`your_data %>% ggplot(aes())`

:::::::::::::::  solution

## Solution to challenge 1

Here is one possible solution:

```{r ch1-sol, fig.cap="Binned scatterplot of life expectancy versus year showing how life expectancy has increased over time"}
eiad_meta_exp %>% filter(Cohort == 'Eye') %>% 
  ggplot(mapping = aes(x = Tissue, y = `KERA (ENSG00000139330)`, color = Sub_Tissue)) + 
  geom_point()
```
## New Plot
Let's now use our dplyr knowledge and look at gene expression changes over time in a small number of early development tissues.

```{r}
eiad_meta_exp %>% 
  mutate(Age_Days = as.integer(Age_Days)) %>% 
  filter(Tissue == 'Retina', !is.na(Age_Days)) %>% 
  ggplot(aes(x=as.integer(Age_Days),
             y=`RHO (ENSG00000163914)`)) + 
  geom_point() 
```
## Layers

Perhaps a scatterplot probably isn't the best for visualizing change over time.
Instead, let's tell `ggplot` to visualize the data as a line plot:

```{r rho line}
eiad_meta_exp %>% 
  mutate(Age_Days = as.integer(Age_Days)) %>% 
  filter(Tissue == 'Retina', !is.na(Age_Days)) %>% 
  ggplot(aes(x=as.integer(Age_Days),
             y=`RHO (ENSG00000163914)`)) + 
  geom_line()
```

Instead of adding a `geom_point` layer, we've added a `geom_line` layer.

However, the result doesn't look quite as we might have expected: it seems to be jumping around a lot. What we actually want is a line that summarizes (or smooths) the trends.

## Statistical Functions

```{r rho smooth line}
eiad_meta_exp %>% 
  mutate(Age_Days = as.integer(Age_Days)) %>% 
  filter(Tissue == 'Retina', !is.na(Age_Days)) %>% 
  ggplot(aes(x=as.integer(Age_Days),
             y=`RHO (ENSG00000163914)`)) + 
  geom_smooth()
```

Now perhaps we would like to see the linear trend. What is plotted in a "loess" which is a smoothed curve across the data. 
```{r}
eiad_meta_exp %>% 
  mutate(Age_Days = as.integer(Age_Days)) %>% 
  filter(Tissue == 'Retina', !is.na(Age_Days)) %>% 
  ggplot(aes(x=as.integer(Age_Days),
             y=`RHO (ENSG00000163914)`)) + 
  geom_smooth(method = 'lm')
```

## Multiple Layers

How do we make the dots come back....any ideas?

```{r}
eiad_meta_exp %>% 
  mutate(Age_Days = as.integer(Age_Days)) %>% 
  filter(Tissue == 'Retina', !is.na(Age_Days)) %>% 
  ggplot(aes(x=as.integer(Age_Days),
             y=`RHO (ENSG00000163914)`)) + 
  geom_smooth(method = 'lm') +
  geom_point()
```
## Order of operations

How do we get the line in FRONT of the dots?????
```{r}
eiad_meta_exp %>% 
  mutate(Age_Days = as.integer(Age_Days)) %>% 
  filter(Tissue == 'Retina', !is.na(Age_Days)) %>% 
  ggplot(aes(x=as.integer(Age_Days),
             y=`RHO (ENSG00000163914)`)) + 
  geom_point() +
  geom_smooth(method = 'lm') 
```

# Color aesthetics
Now we have different KINDS of retina here. More specifically we have three sources of retina (ESC, organoid, primary tissue). How do we separate the lines for each group?
```{r}
eiad_meta_exp %>% 
  mutate(Age_Days = as.integer(Age_Days)) %>% 
  filter(Tissue == 'Retina', !is.na(Age_Days)) %>% 
  ggplot(aes(x=as.integer(Age_Days),
             y=`RHO (ENSG00000163914)`, 
             color = Source)) + 
  geom_point() + geom_smooth(method = 'lm')
```
# Where the aes goes is very important

This is visually a lot to look at...what if you want to just color the lines?
```{r}
eiad_meta_exp %>% 
  mutate(Age_Days = as.integer(Age_Days)) %>% 
  filter(Tissue == 'Retina', !is.na(Age_Days)) %>% 
  ggplot(aes(x=as.integer(Age_Days),
             y=`RHO (ENSG00000163914)`)) + 
  geom_point() + 
  geom_smooth(aes(color = Source), method = 'lm') 
```



:::::::::::::::::::::::::::::::::::::::::  callout

## Tip: Setting an aesthetic to a value instead of a mapping

So far, we've seen how to use an aesthetic (such as **color**) as a *mapping* to a variable in the data. For example, when we use `geom_line(mapping = aes(color=Age_Source))`, ggplot will give a different color to each continent. But what if we want to change the color of all lines to blue? You may think that `geom_line(mapping = aes(color="blue"))` should work, but it doesn't. Since we don't want to create a mapping to a specific variable, we can move the color specification outside of the `aes()` function, like this: `geom_line(color="blue")`.
```{r}
eiad_meta_exp %>% 
  mutate(Age_Days = as.integer(Age_Days)) %>% 
  filter(Tissue == 'Retina', !is.na(Age_Days)) %>% 
  ggplot(aes(x=as.integer(Age_Days),
             y=`RHO (ENSG00000163914)`)) + 
  geom_point(color = 'red') + 
  geom_smooth(aes(color = Source), method = 'lm') 
```


The red dots are REALLY distracting though. We can also modify the transparency of the
points, using the *alpha* function, which is especially helpful when you have
a large amount of data which is very clustered.

```{r axis-scale, fig.cap="Scatterplot of GDP vs life expectancy showing logarithmic x-axis data spread"}
eiad_meta_exp %>% 
  mutate(Age_Days = as.integer(Age_Days)) %>% 
  filter(Tissue == 'Retina', !is.na(Age_Days)) %>% 
  ggplot(aes(x=as.integer(Age_Days),
             y=`RHO (ENSG00000163914)`)) + 
  geom_point(color = 'red', alpha =0.5) + 
  geom_smooth(aes(color = Source), method = 'lm')
```

:::::::::::::::::::::::::::::::::::::::::  callout

## Tip Reminder: Setting an aesthetic to a value instead of a mapping

Notice that we used `geom_point(alpha = 0.5)`. As the previous tip mentioned, using a setting outside of the `aes()` function will cause this value to be used for all points, which is what we want in this case. But just like any other aesthetic setting, *alpha* can also be mapped to a variable in the data. For example, we can give a different transparency to each continent with `geom_point(mapping = aes(alpha = continent))`.


::::::::::::::::::::::::::::::::::::::::::::::::::


We can make the line thicker by *setting* the **size** aesthetic in the
`geom_smooth` layer:

```{r sizing}
eiad_meta_exp %>% 
  mutate(Age_Days = as.integer(Age_Days)) %>% 
  filter(Tissue == 'Retina', !is.na(Age_Days)) %>% 
  ggplot(aes(x=as.integer(Age_Days),
             y=`RHO (ENSG00000163914)`)) + 
  geom_point(color = 'red', alpha =0.5) + 
  geom_smooth(aes(color = Source), method = 'lm', size = 10)
```


:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

## Multi-panel figures

Earlier we visualized the change in life expectancy over time across all
countries in one plot. Alternatively, we can split this out over multiple panels
by adding a layer of **facet** panels.

:::::::::::::::::::::::::::::::::::::::::  callout



::::::::::::::::::::::::::::::::::::::::::::::::::

```{r facet}
eiad_meta_exp %>% 
  mutate(Age_Days = as.integer(Age_Days)) %>% 
  filter(Tissue == 'Retina', !is.na(Age_Days)) %>% 
  ggplot(aes(x=as.integer(Age_Days),
             y=`RHO (ENSG00000163914)`)) + 
  geom_point(color = 'red', alpha =0.5) + 
  geom_smooth(aes(color = Source), method = 'lm') +
  facet_wrap(~study_accession)
```

The `facet_wrap` layer took a "formula" as its argument, denoted by the tilde
(~). 

## Modify x-axis range

Facet wrap, by default, keeps the x axis range (in this case 0 to 600) across all subsets. 
You can modify this behavior if you want to better see the trend in all studies
```{r facet x axis}
eiad_meta_exp %>% 
  mutate(Age_Days = as.integer(Age_Days)) %>% 
  filter(Tissue == 'Retina', !is.na(Age_Days)) %>% 
  ggplot(aes(x=as.integer(Age_Days),
             y=`RHO (ENSG00000163914)`)) + 
  geom_point(color = 'red', alpha =0.5) + 
  geom_smooth(aes(color = Source), method = 'lm') +
  facet_wrap(~study_accession, scales = 'free_x')
```
Hmm, we may want to apply this to both axes

```{r facet both axis}
eiad_meta_exp %>% 
  mutate(Age_Days = as.integer(Age_Days)) %>% 
  filter(Tissue == 'Retina', !is.na(Age_Days)) %>% 
  ggplot(aes(x=as.integer(Age_Days),
             y=`RHO (ENSG00000163914)`)) + 
  geom_point(color = 'red', alpha =0.5) + 
  geom_smooth(aes(color = Source), method = 'lm') +
  facet_wrap(~study_accession, scales = 'free')
```
## Modifying text

To clean this figure up for a publication we need to change some of the text
elements. The x-axis is too cluttered, and the y axis should read
"Life expectancy", rather than the column name in the data frame.

We can do this by adding a couple of different layers. The **theme** layer
controls the axis text, and overall text size. Labels for the axes, plot
title and any legend can be set using the `labs` function. Legend titles
are set using the same names we used in the `aes` specification. Thus below
the color legend title is set using `color = "Continent"`, while the title
of a fill legend would be set using `fill = "MyTitle"`.

```{r theme}
eiad_meta_exp %>% 
  mutate(Age_Days = as.integer(Age_Days)) %>% 
  filter(Tissue == 'Retina', !is.na(Age_Days)) %>% 
  ggplot(aes(x=as.integer(Age_Days),
             y=`RHO (ENSG00000163914)`)) + 
  geom_point(color = 'purple', alpha =0.5) + 
  geom_smooth(aes(color = Source), method = 'lm') +
  facet_wrap(~study_accession) +
  labs(
    x = "Age (Days)",              # x axis title
    y = "Rho, log2(CPM)",   # y axis title
    title = "Rhodopsin is a quantative marker of retinal maturity",      # main title of figure
    color = "Retina Source"      # title of legend
  ) 
```


## Modify color choices
```{r theme brewer}
eiad_meta_exp %>% 
  mutate(Age_Days = as.integer(Age_Days)) %>% 
  filter(Tissue == 'Retina', !is.na(Age_Days)) %>% 
  ggplot(aes(x=as.integer(Age_Days),
             y=`RHO (ENSG00000163914)`)) + 
  geom_point(color = 'purple', alpha =0.5) + 
  geom_smooth(aes(color = Source), method = 'lm') +
  facet_wrap(~study_accession) +
  labs(
    x = "Age (Days)",              # x axis title
    y = "Rho, log2(CPM)",   # y axis title
    title = "Rhodopsin is a quantative marker of retinal maturity",      # main title of figure
    color = "Retina Source"      # title of legend
  ) +
  scale_colour_brewer(palette = 'Set2')
```

## Modify theme
```{r theme classic}
eiad_meta_exp %>% 
  mutate(Age_Days = as.integer(Age_Days)) %>% 
  filter(Tissue == 'Retina', !is.na(Age_Days)) %>% 
  ggplot(aes(x=as.integer(Age_Days),
             y=`RHO (ENSG00000163914)`)) + 
  geom_point(color = 'purple', alpha =0.5) + 
  geom_smooth(aes(color = Source), method = 'lm') +
  facet_wrap(~study_accession) +
  labs(
    x = "Age (Days)",              # x axis title
    y = "Rho, log2(CPM)",   # y axis title
    title = "Rhodopsin is a quantative marker of retinal maturity",      # main title of figure
    color = "Retina Source"      # title of legend
  ) +
  scale_colour_brewer(palette = 'Set2') +
  theme_classic()
```

## Exporting the plot

The `ggsave()` function allows you to export a plot created with ggplot. You can specify the dimension and resolution of your plot by adjusting the appropriate arguments (`width`, `height` and `dpi`) to create high quality graphics for publication. In order to save the plot from above, we first assign it to a variable `lifeExp_plot`, then tell `ggsave` to save that plot in `png` format to a directory called `results`. (Make sure you have a `results/` folder in your working directory.)

```{r directory-check, echo=FALSE}
if (!dir.exists("awesome_plots")) {
  dir.create("awesome_plots")
}
```

```{r save}
awesome_plot <- eiad_meta_exp %>% 
  mutate(Age_Days = as.integer(Age_Days)) %>% 
  filter(Tissue == 'Retina', !is.na(Age_Days)) %>% 
  ggplot(aes(x=as.integer(Age_Days),
             y=`RHO (ENSG00000163914)`)) + 
  geom_point(color = 'purple', alpha =0.5) + 
  geom_smooth(aes(color = Source), method = 'lm') +
  facet_wrap(~study_accession) +
  labs(
    x = "Age (Days)",              # x axis title
    y = "Rho, log2(CPM)",   # y axis title
    title = "Rhodopsin is a quantative marker of retinal maturity",      # main title of figure
    color = "Retina Source"      # title of legend
  ) +
  scale_colour_brewer(palette = 'Set2') +
  theme_classic()

ggsave(filename = "awesome_plots/rho_across_time.svg", plot = awesome_plot, width = 12, height = 10, dpi = 300, units = "cm")
```

There are two nice things about `ggsave`. First, it defaults to the last plot, so if you omit the `plot` argument it will automatically save the last plot you created with `ggplot`. Secondly, it tries to determine the format you want to save your plot in from the file extension you provide for the filename (for example `.png` or `.pdf`). If you need to, you can specify the format explicitly in the `device` argument.

This is a taste of what you can do with ggplot2. RStudio provides a
really useful [cheat sheet][cheat] of the different layers available, and more
extensive documentation is available on the [ggplot2 website][ggplot-doc]. All RStudio cheat sheets are available from the [RStudio website][cheat_all].
Finally, if you have no idea how to change something, a quick Google search will
usually send you to a relevant question and answer on Stack Overflow with reusable
code to modify!

:::::::::::::::::::::::::::::::::::::::  challenge

## Challenge 5

Generate boxplots to compare RPE65 expression across ocular tissues

Advanced:

- Rename axes
- Account for Sub_Tissue
- Fix the "NA" issue for Sub_Tissue
- Customize the appearance for max awesome

:::::::::::::::  solution

## Solution to Challenge 5

Here a possible solution:

```{r ch5-sol}
eiad_meta_exp %>% 
  filter(Cohort == 'Eye') %>% 
  mutate(Sub_Tissue = case_when(is.na(Sub_Tissue) ~ '',
                                TRUE ~ Sub_Tissue)) %>% 
  ggplot(aes(x=Sub_Tissue, y=`RPE65 (ENSG00000116745)`)) +
  
  geom_boxplot() +
  geom_point() + 
  facet_wrap(~Tissue, scale = 'free_y') +
  coord_flip() +
  labs(
    x='RPE65, log2(CPM)',
    y = 'Sub Tissue'
  ) +
  theme_bw()
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

[base]: https://www.statmethods.net/graphs/index.html
[lattice]: https://www.statmethods.net/advgraphs/trellis.html
[ggplot2]: https://www.statmethods.net/advgraphs/ggplot2.html
[cheat]: https://www.rstudio.org/links/data_visualization_cheat_sheet
[cheat_all]: https://www.rstudio.com/resources/cheatsheets/
[ggplot-doc]: https://ggplot2.tidyverse.org/reference/


:::::::::::::::::::::::::::::::::::::::: keypoints

- Use `ggplot2` to create plots.
- Think about graphics in layers: aesthetics, geometry, statistics, scale transformation, and grouping.

::::::::::::::::::::::::::::::::::::::::::::::::::


